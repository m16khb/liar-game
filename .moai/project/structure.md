# Liar Game - 구조 문서

## 전체 아키텍처 개요

### 아키텍처 유형
**모듈형 모놀리스 (Modular Monolith)**
- 단일 애플리케이션 내에서 기능별로 모듈화된 구조
- 향후 마이크로서비스로의 전환 용이성 확보
- 개발 초기 단계의 복잡성 최소화

### 핵심 아키텍처 원칙
1. **도메인 중심 설계**: 게임, 방, 플레이어, 인증 등 명확한 도메인 분리
2. **실시간 통신 우선**: WebSocket을 통한 양방향 통신 기반 설계
3. **상태 관리 중심**: 게임 상태의 일관성과 동기화 보장
4. **확장성 고려**: 컨테이너화와 오케스트레이션 지원

## 디렉터리 구조

```
liar-game/
├── apps/
│   ├── api/                    # NestJS 백엔드 애플리케이션
│   │   ├── src/
│   │   │   ├── auth/          # 인증 모듈
│   │   │   ├── user/          # 사용자 모듈
│   │   │   ├── room/          # 게임 방 모듈
│   │   │   │   ├── entities/  # 방 엔티티
│   │   │   │   ├── dto/       # 데이터 전송 객체
│   │   │   │   ├── gateways/  # WebSocket 게이트웨이
│   │   │   │   └── services/  # 방 관련 비즈니스 로직
│   │   │   ├── player/        # 플레이어 모듈
│   │   │   ├── game/          # 게임 로직 모듈
│   │   │   └── common/        # 공통 모듈
│   │   │       ├── guards/    # 인증 가드
│   │   │       ├── decorators/# 커스텀 데코레이터
│   │   │       └── utils/     # 유틸리티 함수
│   │   └── test/              # API 테스트
│   └── web/                   # React 프론트엔드 애플리케이션
│       ├── src/
│       │   ├── components/    # UI 컴포넌트
│       │   ├── pages/         # 페이지 컴포넌트
│       │   ├── hooks/         # React 훅
│       │   ├── lib/           # 라이브러리 및 API
│       │   ├── services/      # 서비스 레이어
│       │   └── types/         # TypeScript 타입
│       └── public/            # 정적 리소스
├── packages/
│   └── types/                 # 공유 타입 정의
└── docs/                      # 프로젝트 문서
```

## 주요 모듈 및 경계

### 1. 인증 모듈 (auth)
- **책임**: 사용자 인증, JWT 토큰 관리, Supabase 연동
- **주요 컴포넌트**:
  - `auth.controller`: REST API 엔드포인트
  - `supabase-jwt.strategy`: JWT 검증 전략
  - `guards`: 인증/권한 확인 가드
- **팀 책임**: 전체 시스템 보안 관리

### 2. 방 관리 모듈 (room)
- **책임**: 게임 방 생성, 관리, WebSocket 연결 처리
- **주요 컴포넌트**:
  - `room.gateway`: 실시간 통신 처리
  - `room.service`: 방 관리 비즈니스 로직
  - `room.entity`: 방 데이터 모델
- **팀 책임**: 실시간 통신 안정성 책임

### 3. 플레이어 모듈 (player)
- **책임**: 플레이어 상태 관리, 역할 할당, 게임 참여
- **주요 컴포넌트**:
  - `player.service`: 플레이어 로직 처리
  - `player.entity`: 플레이어 데이터 모델
- **팀 책임**: 플레이어 상태 일관성 유지

### 4. 게임 로직 모듈 (game)
- **책임**: 라이어 게임 규칙 구현, 턴 관리, 승리 조건 검증
- **주요 컴포넌트**:
  - `game.service`: 게임 진행 로직
  - `game-engine`: 핵심 게임 엔진
- **팀 책임**: 게임 규칙 정확성 보장

## 외부 시스템 통합

### 1. Supabase (인증 및 데이터베이스)
- **프로토콜**: REST API, WebSocket
- **인증**: JWT 기반 OAuth 2.0
- **용도**:
  - 사용자 인증 및 관리
  - PostgreSQL 데이터베이스 연동
  - 실시간 데이터 동기화
- **실패 전략**: 로컬 캐시 및 재시도 메커니즘

### 2. Redis (캐시 및 세션)
- **프로토콜**: TCP
- **용도**:
  - 게임 상태 캐싱
  - 세션 관리
  - 실시간 데이터 임시 저장
- **실패 전략**: 데이터베이스 fallback

## 데이터 흐름 및 API 설계

### 1. 사용자 인증 흐름
```
Client → Supabase → JWT Token → API Gateway → Auth Guard → Service
```

### 2. 게임 방 생성 흐름
```
Client → REST API → Room Service → Database → WebSocket Broadcast
```

### 3. 실시간 게임 진행 흐름
```
Client → WebSocket → Room Gateway → Game Engine → State Update → Broadcast
```

### API 설계 원칙
- **RESTful**: REST API는 RESTful 원칙 준수
- **실시간**: 게임 진행은 WebSocket으로 처리
- **일관성**: 모든 API는 일관적인 에러 응답 형식 사용
- **버전관리**: API 버전은 URL 경로에 포함 (`/api/v1/`)

## 비기능적 요구사항

### 1. 성능
- **응답시간**: REST API P95 < 200ms
- **지연시간**: WebSocket 메시지 P95 < 100ms
- **처리량**: 1000+ concurrent WebSocket connections
- **측정**: New Relic 또는 커스텀 메트릭 수집

### 2. 가용성
- **목표**: 99.9% 업타임
- **전략**: 다중 인스턴스 배포, 헬스 체크, 자동 재시작
- **장애 처리**: 서킷 브레이커 패턴, 그레이스풀 디그레이이션

### 3. 확장성
- **수평 확장**: 컨테이너 기반의 자동 스케일링
- **부하 분산**: Nginx 또는 클라우드 로드 밸런서
- **데이터 분할**: 게임 방별 샤딩 고려

### 4. 보안
- **인증**: JWT 토큰 기반의 무상태 인증
- **권한**: 역할 기반 접근 제어 (RBAC)
- **암호화**: HTTPS/WSS 프로토콜 강제
- **보안 헤더**: CORS, CSP, HSTS 적용

### 5. 관찰 가능성
- **로깅**: 구조화된 로그 (JSON 형식)
- **메트릭**: Prometheus/Grafana를 통한 시각화
- **트레이싱**: OpenTelemetry를 통한 분산 추적
- **알림**: Slack 또는 이메일을 통한 실시간 알림

## 상태 관리 전략

### 클라이언트 상태
- **저장소**: React Context + useReducer
- **영속성**: 로컬 스토리지 (선택적 데이터)
- **동기화**: 서버 상태와의 지속적인 동기화

### 서버 상태
- **영구 상태**: PostgreSQL (Supabase)
- **일시 상태**: Redis (게임 진행 중)
- **분산**: 여러 인스턴스 간 상태 동기화

## 기술적 의사결정 배경

### 1. 모듈형 모놀리스 선택 이유
- **개발 효율성**: 1인 프로젝트에서의 관리 용이성
- **디버깅 용이성**: 단일 애플리케이션으로 추적의 용이
- **향후 유연성**: 필요시 마이크로서비스로 분리 가능

### 2. WebSocket 선택 이유
- **실시간성 요구**: 게임의 특성상 낮은 지연시간 필수
- **양방향 통신**: 서버-클라이언트 간 실시간 데이터 교환
- **브라우저 호환성**: 넓은 브라우저 지원

### 3. NestJS 선택 이유
- **타입 안전성**: TypeScript 기반의 정적 타입
- **모듈성**: 명확한 모듈 구조 지원
- **생태계**: 풍부한 미들웨어와 가드 시스템

## 향후 개선 계획

### 단기 (1-3개월)
- 게임 상태 동기화 최적화
- 에러 처리 및 재시도 로직 강화
- 기본 모니터링 구축

### 중기 (3-6개월)
- 마이크로서비스 분리 준비
- 이벤트 기반 아키텍처 도입
- 성능 최적화 및 캐싱 전략 고도화

### 장기 (6개월+)
- 글로벌 배포를 위한 멀티 리전 지원
- AI 플레이어 시스템 통합
- 실시간 스트리밍 기능 확장