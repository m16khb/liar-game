# SPEC-DATA-001: 데이터 모델 일관성 및 게임 상태 관리 - 수용 테스트 기준

## 1. 개요

본 문서는 데이터 모델 일관성 확보 및 게임 상태 관리 시스템 구현에 대한 상세한 수용 테스트 기준을 정의합니다. Given-When-Then 형식의 시나리오를 통해 모든 데이터 관리 요구사항이 충족되었는지 검증합니다.

## 2. 수용 테스트 시나리오

### 2.1 데이터 모델 정규화 시나리오

#### 시나리오 1: 제3정규형(3NF) 준수 검증
- **Given** 데이터베이스 스키마가 설계되었을 때
- **When** 정규화 규칙을 검증하면
- **Then** 모든 테이블은 제1정규형을 만족해야 한다 (모든 속성이 원자값)
- **And** 모든 테이블은 제2정규형을 만족해야 한다 (부분적 종속성 없음)
- **And** 모든 테이블은 제3정규형을 만족해야 한다 (이행적 종속성 없음)
- **And** 중복 데이터가 존재하지 않아야 한다

#### 시나리오 2: 참조 무결성 강제
- **Given** Room 엔티티와 Player 엔티티가 1:N 관계를 가질 때
- **When** Room이 삭제되면
- **Then** 관련된 Player 레코드는 CASCADE로 자동 삭제되어야 한다
- **And** 고아 데이터(orphans)가 생성되지 않아야 한다
- **And** 외래키 제약조건이 항상 유효해야 한다

#### 시나리오 3: 고유성 제약 조건
- **Given** GamePlayer 엔티티가 게임과 사용자의 연결 관계를 가질 때
- **When** 동일 사용자가 같은 게임에 두 번 참여하려고 하면
- **Then** Unique 제약조건 위반 오류가 발생해야 한다
- **And** 데이터베이스 레벨에서 중복插入이 차단되어야 한다

### 2.2 상태 관리 시나리오

#### 시나리오 4: 상태 전이 규칙 검증
- **Given** 게임이 WAITING 상태일 때
- **When** FINISHED 상태로 직접 전이를 시도하면
- **Then** InvalidStateTransition 예외가 발생해야 한다
- **And** "허용되지 않는 상태 전이: WAITING -> FINISHED" 메시지가 표시되어야 한다
- **And** 게임 상태는 변경되지 않아야 한다

#### 시나리오 5: 원자적 상태 업데이트
- **Given** 게임 상태 변경과 플레이어 업데이트가 동시에 필요할 때
- **When** 트랜잭션이 실행되면
- **Then** 모든 변경이 원자적으로 처리되어야 한다
- **And** 중간에 실패하면 모든 변경이 롤백되어야 한다
- **And** 부분적인 업데이트가 발생하지 않아야 한다

#### 시나리오 6: 낙관적 잠금 충돌 감지
- **Given** 게임 데이터가 version 5로 저장되어 있을 때
- **When** 두 개의 동시 요청이 version 5로 업데이트를 시도하면
- **Then** 첫 번째 요청은 성공하고 version이 6으로 증가해야 한다
- **And** 두 번째 요청은 OptimisticLockError를 받아야 한다
- **And** 데이터는 첫 번째 요청의 변경 사항만 반영되어야 한다

#### 시나리오 7: 버전 충돌 재시도
- **Given** 낙관적 잠금 충돌이 발생했을 때
- **When** 클라이언트가 재시도 로직을 실행하면
- **Then** 최신 데이터를 다시 조회해야 한다
- **And** 새 버전 번호로 업데이트를 시도해야 한다
- **And** 최대 3회까지 재시도해야 한다

### 2.3 캐싱 전략 시나리오

#### 시나리오 8: Cache-Aside 패턴 동작
- **Given** 게임 데이터가 캐시에 없을 때
- **When** GET /api/games/{id} 요청이 오면
- **Then** 먼저 Redis 캐시를 조회해야 한다
- **And** 캐시 미스이면 PostgreSQL에서 데이터를 조회해야 한다
- **And** 조회된 데이터를 캐시에 저장해야 한다 (TTL: 5분)
- **And** 클라이언트에게 데이터를 반환해야 한다

#### 시나리오 9: 캐시 일관성 유지
- **Given** 게임 데이터가 캐시와 DB에 저장되어 있을 때
- **When** 게임 상태가 PLAYING으로 변경되면
- **Then** 데이터베이스 업데이트와 캐시 무효화가 동시에 일어나야 한다
- **And** 캐시 무효화는 관련된 모든 키에 대해 실행되어야 한다
- **And** 다음 요청 시 최신 데이터를 가져와야 한다

#### 시나리오 10: 캐시 성능 측정
- **Given** 1000개의 활성 게임이 있을 때
- **When** 10000회의 게임 조회 요청을 보내면
- **Then** 캐시 적중률이 90% 이상이어야 한다
- **And** 평균 응답시간이 10ms 미만이어야 한다
- **And** 데이터베이스 부하가 1000회 미만이어야 한다

#### 시나리오 11: 캐시 워밍업
- **Given** 서버가 재시작될 때
- **When** 자주 접근되는 게임 ID 목록으로 워밍업을 실행하면
- **Then** 자주 접근되는 게임 데이터가 미리 캐시에 로드되어야 한다
- **And** 서비스 시작 후 첫 요청의 지연이 줄어야 한다

### 2.4 동시성 제어 시나리오

#### 시나리오 12: 동시 플레이어 참여
- **Given** 게임 방에 정원(8명)이 1명 남았을 때
- **When** 3명이 동시에 참여를 시도하면
- **Then** 먼저 도착한 1명만 성공해야 한다
- **And** 나머지 2명은 "방이 꽉 찼습니다" 메시지를 받아야 한다
- **And** 방의 현재 인원수는 8로 정확하게 유지되어야 한다

#### 시나리오 13: 분산 환경 상태 동기화
- **Given** 3개의 서버 인스턴스가 로드 밸런서 뒤에서 실행될 때
- **When** 서버 A에서 게임 상태를 변경하면
- **Then** Redis Pub/Sub을 통해 다른 서버들에게 알림이 가야 한다
- **And** 모든 서버의 캐시가 무효화되어야 한다
- **And** 모든 클라이언트가 일관된 상태를 보여야 한다

#### 시나리오 14: 대량 트랜잭션 처리
- **Given** 100개의 게임 방에서 동시에 상태 변경이 발생할 때
- **When** 각 게임에서 턴 전환이 일어나면
- **Then** 모든 트랜잭션이 100ms 내에 완료되어야 한다
- **And** 데드락이 발생하지 않아야 한다
- **And** 데이터 일관성이 유지되어야 한다

### 2.5 데이터 마이그레이션 시나리오

#### 시나리오 15: Zero-downtime 마이그레이션
- **Given** 운영 중인 서비스에 새로운 컬럼을 추가할 때
- **When** 마이그레이션 스크립트를 실행하면
- **Then** 서비스 중단 없이 마이그레이션이 완료되어야 한다
- **And** 기존 API 요청들이 계속 정상 처리되어야 한다
- **And** 새로운 컬럼이 NULL 허용으로 추가되어야 한다

#### 시나리오 16: 데이터 이전 정확성
- **Given** Room 테이블의 settings 컬럼을 JSONB로 마이그레이션할 때
- **When** 마이그레이션이 완료되면
- **Then** 모든 데이터가 정확하게 이전되어야 한다
- **And** 데이터 타입이 올바르게 변환되어야 한다
- **And** 데이터 손실이 없어야 한다 (0% 데이터 손실)

#### 시나리오 17: 롤백 안정성
- **Given** 마이그레이션 중 오류가 발생했을 때
- **When** 롤백 마이그레이션을 실행하면
- **Then** 데이터베이스가 이전 상태로 완전히 복원되어야 한다
- **And** 애플리케이션 정상적으로 동작해야 한다
- **And** 데이터 무결성이 보장되어야 한다

### 2.6 성능 최적화 시나리오

#### 시나리오 18: 인덱스 효율성
- **Given** GamePlayers 테이블에 100만 개의 레코드가 있을 때
- **When** 특정 게임의 모든 플레이어를 조회하면
- **Then** 인덱스를 사용해 쿼리가 실행되어야 한다
- **And** 쿼리 실행 시간이 10ms 미만이어야 한다
- **And** EXPLAIN ANALYZE에 Index Scan이 표시되어야 한다

#### 시나리오 19: N+1 문제 해결
- **Given** 10개의 게임과 각 게임당 10개의 액션 기록이 있을 때
- **When** 모든 게임과 액션을 함께 조회하면
- **Then** 단일 쿼리로 모든 데이터를 가져와야 한다 (JOIN 사용)
- **Or** 배치 로딩으로 최대 2개의 쿼리만 실행해야 한다
- **And** 11개 이상의 쿼리가 실행되지 않아야 한다

#### 시나리오 20: 페이징 성능
- **Given** 100,000개의 게임 기록이 있을 때
- **When** 1000페이지를 조회할 때 (OFFSET 99900, LIMIT 100)
- **Then** 커서 기반 페이징을 사용하면 응답시간이 50ms 미만이어야 한다
- **And** OFFSET/LIMIT을 사용하더라도 200ms 미만으로 응답해야 한다

#### 시나리오 21: 복합 인덱스 최적화
- **Given** 활성 게임 필터링 조회가 빈번할 때
- **When** status = 'PLAYING' AND phase = 'DISCUSSING' 조건으로 조회하면
- **Then** 복합 인덱스 (status, phase)가 사용되어야 한다
- **And** 전체 테이블 스캔이 발생하지 않아야 한다

### 2.7 데이터 아카이빙 시나리오

#### 시나리오 22: 오래된 데이터 아카이빙
- **Given** 30일이 지난 완료된 게임들이 있을 때
- **When** 아카이빙 작업이 실행되면
- **Then** 오래된 게임들이 archived_games 테이블로 이동되어야 한다
- **And** 원본 테이블에서는 삭제되어야 한다
- **And** 최근 30일 이내의 데이터는 유지되어야 한다

## 3. 부하 테스트 시나리오

### 3.1 고부하 테스트

#### 시나리오 23: 동시 게임 진행 부하 테스트
- **Given** 시스템이 정상 운영 중일 때
- **When** 100개의 게임 방에서 동시에 게임을 진행하면
- **Then** 모든 게임이 지연 없이 진행되어야 한다
- **And** P95 응답시간이 200ms 미만이어야 한다
- **And** 에러율이 0.1% 미만이어야 한다

#### 시나리오 24: 캐시 부하 테스트
- **Given** 캐시 서비스가 정상일 때
- **When** 10,000 RPS의 캐시 요청을 보내면
- **Then** 캐시 서비스가 안정적으로 응답해야 한다
- **And** P99 응답시간이 5ms 미만이어야 한다
- **And** 메모리 사용량이 80% 미만이어야 한다

### 3.2 장시간 안정성 테스트

#### 시나리오 25: 24시간 지속 부하 테스트
- **Given** 시스템에 안정성 테스트를 시작할 때
- **When** 24시간 동안 평균 부하(100 TPS)를 유지하면
- **Then** 메모리 누수가 발생하지 않아야 한다
- **And** 데이터베이스 연결풀이 안정적으로 유지되어야 한다
- **And** 성능 저하가 10% 미만이어야 한다

## 4. 회복 시나리오

### 4.1 장애 복구

#### 시나리오 26: 캐시 장애 복구
- **Given** Redis 서비스가 장애 발생했을 때
- **When** 캐시 요청이 실패하면
- **Then** 시스템은 그레이스풀 디그레이션되어야 한다
- **And** 데이터베이스에서 직접 데이터를 조회해야 한다
- **And** 서비스는 계속 정상적으로 동작해야 한다

#### 시나리오 27: 데이터베이스 장애 복구
- **Given** 프라이머리 데이터베이스에 장애가 발생했을 때
- **When** 읽기 전용 복제본으로 자동 전환되면
- **Then** 읽기 요청은 복제본으로 전달되어야 한다
- **And** 쓰기 요청은 대기열에 저장되어야 한다
- **And** 복구 후 자동으로 동기화되어야 한다

## 5. 데이터 검증 시나리오

### 5.1 무결성 검증

#### 시나리오 28: 데이터 정합성 검증
- **Given** 정기 데이터 검증 작업이 실행될 때
- **When** 모든 게임 방의 플레이어 수를 검증하면
- **Then** room.currentPlayers와 실제 player 테이블의 수가 일치해야 한다
- **And** 불일치가 발견되면 자동으로 수정되어야 한다
- **And** 수정 로그가 기록되어야 한다

#### 시나리오 29: 외래키 무결성
- **Given** 정기 외래키 검증을 실행할 때
- **When** 모든 테이블의 참조 관계를 확인하면
- **Then** 참조하는 부모 레코드가 모두 존재해야 한다
- **And** 고아 데이터가 발견되면 정리 프로세스를 실행해야 한다
- **And** 보고서가 생성되어야 한다

## 6. 성능 수용 기준

### 6.1 응답 시간 기준
- **데이터 조회**: P95 < 100ms
- **상태 업데이트**: P95 < 50ms
- **캐시 조회**: P95 < 10ms
- **복잡한 JOIN**: P95 < 200ms

### 6.2 처리량 기준
- **동시 트랜잭션**: 1000 TPS
- **캐시 처리량**: 10,000 RPS
- **DB 연결풀**: 최대 100개 연결

### 6.3 자원 사용률 기준
- **CPU 사용률**: 평균 < 50%
- **메모리 사용률**: < 80%
- **디스크 I/O**: < 70%
- **네트워크 대역폭**: < 60%

## 7. 테스트 실행 도구

### 7.1 자동화된 테스트
```bash
# 데이터베이스 마이그레이션 테스트
npm run test:migration

# 성능 벤치마크
npm run test:performance

# 동시성 테스트
npm run test:concurrency

# 데이터 무결성 검증
npm run test:integrity
```

### 7.2 부하 테스트 도구
- **k6**: API 부하 테스트
- **JMeter**: 복합 시나리오 테스트
- **pgbench**: PostgreSQL 벤치마크
- **redis-benchmark**: Redis 성능 테스트

## 8. Definition of Done

### 8.1 필수 조건
- [ ] 모든 수용 테스트 시나리오 통과
- [ ] 데이터 모델 3NF 준수
- [ ] 성능 벤치마크 모든 기준 달성
- [ ] 동시성 테스트 1000 TPS 통과
- [ ] 캐시 히트률 90% 달성

### 8.2 선택 조건
- [ ] 24시간 안정성 테스트 통과
- [ ] 장애 복구 시나리오 모두 통과
- [ ] 100만 개 데이터 처리 능력 확인
- [ ] 샤딩 준비 완료

### 8.3 운영 준비
- [ ] 데이터 모니터링 대시보드 구축
- [ ] 자동 데이터 검증 스케줄 설정
- [ ] 장애 복구 매뉴얼 작성
- [ ] 성능 튜닝 가이드 준비